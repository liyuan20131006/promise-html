<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>javascript--栈的算法结构</title>
  <script type="text/javascript">
    //定义栈
    function Stack(){
      this.dataStore = []
      this.top = 0 //记录栈顶的位置
      this.push = push //入栈
      this.pop = pop //出栈
      this.peek = peek //查看栈顶元素
      this.length = size //查看当前栈元素总数
      this.clear = clear //清空栈内元素
    }
    //该方法将一个新元素入栈，放到数组中 top 所对应的位置上，并将 top 的值加 1，让其指向数组的下一个空位置
    function push(element){
      this.dataStore[this.top++] = element
    }
    //该方法与入栈相反，返回栈顶元素，并将 top 的值减 1
    function pop(){
      return this.top>0?this.dataStore[--this.top]:'Empty'
    }
    //该方法返回的是栈顶元素，即 top - 1 个位置元素
    function peek(){
      return this.top>0?this.dataStore[this.top-1]:'Empty'
    }
    //该方法通过返回 top 属性的值来返回栈内总的元素个数
    function size(){
      return this.top
    }
    //该方法实现很简单，我们将 top 值置为 0 ， dataStore 数值清空即可
    function clear(){
      delete this.dataStore
      this.dataStore = []
      this.top = 0
    }
    let _stack = new Stack()
    _stack.push(1)
    _stack.push(2)
    _stack.push(3)
    //console.log(_stack.pop(),_stack.pop(),_stack.pop(),_stack.pop())
    console.log(_stack.peek()) //输出：3
    console.log(_stack.pop())  //输出：3
    _stack.push(4)
    console.log(_stack.length()) //输出：3
    _stack.clear()
    //console.log(_stack.top,_stack.dataStore,_stack.peek())
    console.log(_stack.length()) //输出：0
    console.log(_stack.peek())  //输出：Empty

    //案例一：实现数制间的相互转换（2-9）
    function mulBase(num,base){
      var s = new Stack()
      do{
        s.push( num%base )
        num = Math.floor(num / base)
        //console.log('num:',num)
      }while(num>0);
      var _str = '';
      while(s.length()>0){
        _str+=s.pop()
      }
      return _str
    }
    console.log(mulBase(3,2)) //输出：11
    console.log(mulBase(5,2)) //输出：101
    console.log(mulBase(125,2)) //输出：1111101
    console.log(mulBase(65,2))

    //案例二：判断是否是回文（比如：level、1001、racecar）
    function isPalindrome (word){
      var _wordStack = new Stack()
      for(var i=0,len = word.length;i<len;i++){
        //console.log(word[i])
        _wordStack.push(word[i])
      }
     // console.log(_wordStack)
      var _reverse = ""
      for(var w =0,len=_wordStack.length();w<len;w++){
        _reverse+=_wordStack.pop()
      }
      //console.log(_reverse)
      return word === _reverse
    }
    console.log(isPalindrome('level'))   //输出：true
    console.log(isPalindrome('racecar')) //输出：true
    console.log(isPalindrome('reverse')) //输出：false
  </script>
</head>
<body>
  
</body>
</html>